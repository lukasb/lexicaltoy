import { MutableRefObject } from "react";
import { 
  FormulaEditorNode,
  FormulaDisplayNode,
  $isFormulaDisplayNode,
  $createFormulaDisplayNode,
} from "@/_app/nodes/FormulaNode";
import { 
  LexicalEditor,
  SELECTION_CHANGE_COMMAND,
  COMMAND_PRIORITY_EDITOR,
  $getSelection,
  $isRangeSelection,
  $getNodeByKey,
  $isNodeSelection,
  DELETE_CHARACTER_COMMAND,
  $isElementNode,
  COMMAND_PRIORITY_HIGH,
  CUT_COMMAND,
  COMMAND_PRIORITY_CRITICAL,
  REMOVE_TEXT_COMMAND,
  OUTDENT_CONTENT_COMMAND,
  INSERT_PARAGRAPH_COMMAND,
  $isTextNode
} from "lexical";
import {
  ListItemNode,
  $isListItemNode,
} from "@lexical/list";
import { mergeRegister } from "@lexical/utils";
import { 
  $getActiveListItemFromSelection,
  $getListItemContainingNode,
  getAncestorListItem
} from "@/lib/list-utils";
import { 
  SWAP_FORMULA_DISPLAY_FOR_EDITOR,
  STORE_FORMULA_OUTPUT,
  CREATE_FORMULA_NODES
} from "@/lib/formula-commands";
import { parseFormulaMarkdown } from "@/lib/formula/formula-markdown-converters";
import { BaseNodeMarkdown } from "@/lib/formula/formula-definitions";
import {
  $replaceWithFormulaDisplayNode,
  createFormulaOutputNodes,
  haveExistingFormulaEditorNode,
  $replaceExistingFormulaEditorNode,
  $replaceDisplayNodeWithEditor,
  $replaceTextNodeWithEditor,
  $replaceEditorWithTextNode,
  getFormulaEditorNodeKey
} from "./formula-node-helpers"
import { 
  FormattableTextNode
} from "@/_app/nodes/FormattableTextNode";
import { 
  INDENT_LISTITEM_COMMAND,
  OUTDENT_LISTITEM_COMMAND
} from "@/lib/list-commands";
import { ChildSharedNodeReference } from ".";

function getAncestorFormulaDisplayNode(listItem: ListItemNode | null): FormulaDisplayNode | null {
  if (!listItem) return null;
  let ancestorListItem = getAncestorListItem(listItem);
  while (ancestorListItem) {
    const previousSibling = ancestorListItem.getPreviousSibling();
    if ($isElementNode(previousSibling) 
      && $isFormulaDisplayNode(previousSibling.getChildren()[0])) 
    {
      return previousSibling.getChildren()[0] as FormulaDisplayNode;
    }
    ancestorListItem = getAncestorListItem(ancestorListItem);
  }
  return null;
}

// we don't want to let people delete nodes generated by a FormulaDisplayNode
// for now, if selection spans ListItemNodes under a FormulaDisplayNode, we don't allow deletion
function $shouldNotDelete(): boolean {
  const selection = $getSelection();
  if (selection === null || !$isRangeSelection(selection) || selection.isCollapsed()) return false;
  const anchorLI = $getListItemContainingNode(selection.anchor.getNode());
  const focusLI = $getListItemContainingNode(selection.focus.getNode());
  if (anchorLI === focusLI) return false;
  const anchorAncestor = getAncestorFormulaDisplayNode(anchorLI);
  const focusAncestor = getAncestorFormulaDisplayNode(focusLI);
  if (anchorAncestor || focusAncestor) return true;
  return false;
}

export function registerFormulaCommandHandlers(
  editor: LexicalEditor,
  updatingNodeKey: MutableRefObject<string | null>,
  setUpdatingNodeKey: (updatingNodeKey: string | null) => void,
  setLocalSharedNodeMap: React.Dispatch<React.SetStateAction<Map<string, BaseNodeMarkdown>>>,
  setLocalChildNodeMap: React.Dispatch<React.SetStateAction<Map<string, ChildSharedNodeReference>>>
  ) {
    return mergeRegister(
      editor.registerNodeTransform(FormattableTextNode, (node) => {
        const parentNode = node.getParent();
        if (
          !(parentNode instanceof ListItemNode) ||
          node.getIndexWithinParent() !== 0 ||
          node instanceof FormulaEditorNode
        ) {
          return;
        }
        const textContents = parentNode.getTextContent();
        const { formula: formulaText, result: resultString } =
          parseFormulaMarkdown(textContents);
        if (formulaText && resultString) {
          const formulaDisplayNode = $createFormulaDisplayNode(
            formulaText,
            resultString
          );
          parentNode.splice(
            0,
            parentNode.getChildrenSize(),
            [formulaDisplayNode]
          );
          //node.replace(formulaDisplayNode);
        } else if (textContents.startsWith("=")) {
          $replaceTextNodeWithEditor(node);
        }
      }),
      editor.registerNodeTransform(FormulaEditorNode, (node) => {
        // this logic is mostly around making sure if we serialize a FormulaEditorNode
        // that it is turned back into a FormulaDisplayNode when the editor is reloaded
        // TODO maybe handle this in FormulaEditorNode.importJSON instead?
        const textContents = node.getTextContent();

        if (!textContents.startsWith("=")) {
          $replaceEditorWithTextNode(node);
        } else {
          const selection = $getSelection();
          if (
            selection === null ||
            !$isRangeSelection(selection) ||
            !selection.isCollapsed()
          ) {
            $replaceWithFormulaDisplayNode(node);
          }
          const selectionListItemNode =
            $getActiveListItemFromSelection(selection);
          if (selectionListItemNode) {
            const editorListItemNode = node.getParent();
            if (
              editorListItemNode && 
              selectionListItemNode.getKey() !== editorListItemNode.getKey()
            ) {
              $replaceWithFormulaDisplayNode(node);
            }
          }
        }
      }),
      editor.registerCommand(
        SELECTION_CHANGE_COMMAND,
        () => {
          const selection = $getSelection();
          if (selection === null) return false;

          if ($isNodeSelection(selection)) {
            const node = selection.getNodes()[0];
            if (
              haveExistingFormulaEditorNode() &&
              node.getKey() !== getFormulaEditorNodeKey()
            ) {
              $replaceExistingFormulaEditorNode();
            }
            if ($isFormulaDisplayNode(node)) {
              $replaceDisplayNodeWithEditor(node);
            } else if ($isListItemNode(node)) {
              const listItemNode = node;
              if (
                listItemNode?.getChildren()[0] instanceof FormulaDisplayNode
              ) {
                $replaceDisplayNodeWithEditor(
                  listItemNode.getChildren()[0] as FormulaDisplayNode
                );
              }
            }
            return false;
          }

          if (!$isRangeSelection(selection) || !selection.isCollapsed()) {
            return false;
          }

          const activeNode = selection.anchor.getNode();

          if (
            haveExistingFormulaEditorNode() &&
            activeNode.getKey() !== getFormulaEditorNodeKey()
          ) {
            // we're about to get rid of the node that has (had) the selection
            // before the selection change handler has completed, so we have to
            // fix the selection here
            let anchorOffset = undefined;
            if ($isTextNode(activeNode)) {
              anchorOffset = selection.anchor.offset;
            }
            $replaceExistingFormulaEditorNode();
            if (anchorOffset) {
              activeNode.select(anchorOffset);
            } else {
              activeNode.selectEnd();
            }
          }

          const listItemNode = $getActiveListItemFromSelection(selection);
          if (
            listItemNode &&
            listItemNode.getChildren()[0] instanceof FormulaDisplayNode
          ) {
            $replaceDisplayNodeWithEditor(
              listItemNode.getChildren()[0] as FormulaDisplayNode
            );
          }

          return false;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        SWAP_FORMULA_DISPLAY_FOR_EDITOR,
        ({ displayNodeKey }) => {
          const displayNode = $getNodeByKey(displayNodeKey);
          if (displayNode && $isFormulaDisplayNode(displayNode)) {
            $replaceDisplayNodeWithEditor(displayNode);
          }
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        STORE_FORMULA_OUTPUT,
        ({ displayNodeKey, output }) => {
          const displayNode = $getNodeByKey(displayNodeKey);
          if (displayNode && $isFormulaDisplayNode(displayNode)) {
            displayNode.setOutput(output);
          }
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        CREATE_FORMULA_NODES,
        ({ displayNodeKey, nodesMarkdown }) => {

          // don't recreate the nodes if the given display node is the source of the update
          if (displayNodeKey === updatingNodeKey.current) {
            setUpdatingNodeKey(null);
            return true;
          }
          const displayNode = $getNodeByKey(displayNodeKey);
          if (displayNode && $isFormulaDisplayNode(displayNode)) {
            createFormulaOutputNodes(
              editor,
              displayNode,
              nodesMarkdown,
              setLocalSharedNodeMap,
              setLocalChildNodeMap
            );
          }
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        DELETE_CHARACTER_COMMAND,
        () => {
          return $shouldNotDelete();
        },
        COMMAND_PRIORITY_HIGH
      ),
      editor.registerCommand(
        REMOVE_TEXT_COMMAND,
        () => {
          return $shouldNotDelete();
        }, 
        COMMAND_PRIORITY_CRITICAL
      ),
      editor.registerCommand(
        CUT_COMMAND,
        () => {
          return $shouldNotDelete();
        }, 
        COMMAND_PRIORITY_CRITICAL
      ),
      editor.registerCommand(
        INDENT_LISTITEM_COMMAND,
        (payload) => {
          const { listItem } = payload;
          const formulaDisplayNode = getAncestorFormulaDisplayNode(listItem);
          if (formulaDisplayNode) {
            return true;
          }
          return false;
        },
        COMMAND_PRIORITY_HIGH
      ),
      editor.registerCommand(
        OUTDENT_LISTITEM_COMMAND,
        (payload) => {
          const { listItem } = payload;
          const formulaDisplayNode = getAncestorFormulaDisplayNode(listItem);
          if (formulaDisplayNode) {
            return true;
          }
          return false;
        },
        COMMAND_PRIORITY_HIGH
      ),
      editor.registerCommand(
        OUTDENT_CONTENT_COMMAND,
        (payload) => {
          const selection = $getSelection();
          if (selection === null || !$isRangeSelection(selection) || !selection.isCollapsed()) return false;
          const anchorLI = $getListItemContainingNode(selection.anchor.getNode());
          if (!anchorLI) return false;
          const anchorAncestor = getAncestorFormulaDisplayNode(anchorLI);
          if (anchorAncestor) return true;
          return false;
        },
        COMMAND_PRIORITY_HIGH
      ),
      editor.registerCommand(
        INSERT_PARAGRAPH_COMMAND,
        (payload) => {
          const selection = $getSelection();
          if (selection === null || !$isRangeSelection(selection) || !selection.isCollapsed()) return false;
          const anchorLI = $getListItemContainingNode(selection.anchor.getNode());
          if (!anchorLI) return false;
          const displayNode = getAncestorFormulaDisplayNode(anchorLI);
          if (displayNode) return true;
          return false;
        },
        COMMAND_PRIORITY_HIGH
      ),
    );
  }