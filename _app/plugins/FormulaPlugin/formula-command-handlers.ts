import { MutableRefObject } from "react";
import { 
  FormulaEditorNode,
  FormulaDisplayNode,
  $isFormulaDisplayNode,
  $createFormulaDisplayNode,
  $isFormulaEditorNode
} from "@/_app/nodes/FormulaNode";
import { 
  LexicalEditor,
  SELECTION_CHANGE_COMMAND,
  COMMAND_PRIORITY_EDITOR,
  $getSelection,
  $isRangeSelection,
  $getNodeByKey,
  $isNodeSelection,
  DELETE_CHARACTER_COMMAND,
  $isElementNode,
  COMMAND_PRIORITY_HIGH,
  CUT_COMMAND,
  COMMAND_PRIORITY_CRITICAL,
  REMOVE_TEXT_COMMAND,
  OUTDENT_CONTENT_COMMAND,
  INSERT_PARAGRAPH_COMMAND,
  COPY_COMMAND,
  $isTextNode,
  PASTE_COMMAND,
} from "lexical";
import {
  ListItemNode,
} from "@lexical/list";
import { mergeRegister } from "@lexical/utils";
import { 
  $getActiveListItemFromSelection,
  $getListItemContainingNode,
  getAncestorListItem
} from "@/lib/list-utils";
import { 
  SWAP_FORMULA_DISPLAY_FOR_EDITOR,
  SWAP_FORMULA_EDITOR_FOR_DISPLAY,
  STORE_FORMULA_OUTPUT,
  CREATE_FORMULA_NODES,
  ADD_FORMULA_NODES
} from "@/lib/formula-commands";
import { parseFormulaMarkdown } from "@/lib/formula/formula-markdown-converters";
import { BaseNodeMarkdown, NodeElementMarkdown } from "@/lib/formula/formula-definitions";
import {
  $replaceWithFormulaDisplayNode,
  createFormulaOutputNodes,
  haveExistingFormulaEditorNode,
  $replaceExistingFormulaEditorNode,
  $replaceDisplayNodeWithEditor,
  $replaceTextNodeWithEditor,
  $replaceEditorWithTextNode,
  getFormulaEditorNodeKey,
  addFormulaOutputNodes
} from "./formula-node-helpers"
import { 
  FormattableTextNode
} from "@/_app/nodes/FormattableTextNode";
import { 
  INDENT_LISTITEM_COMMAND,
  OUTDENT_LISTITEM_COMMAND
} from "@/lib/list-commands";
import { ChildSharedNodeReference } from ".";

function getAncestorFormulaDisplayNode(listItem: ListItemNode | null): FormulaDisplayNode | null {
  if (!listItem) return null;
  let ancestorListItem = getAncestorListItem(listItem);
  while (ancestorListItem) {
    const previousSibling = ancestorListItem.getPreviousSibling();
    if ($isElementNode(previousSibling) 
      && $isFormulaDisplayNode(previousSibling.getChildren()[0])) 
    {
      return previousSibling.getChildren()[0] as FormulaDisplayNode;
    }
    ancestorListItem = getAncestorListItem(ancestorListItem);
  }
  return null;
}

// we don't want to let people delete nodes generated by a FormulaDisplayNode
// for now, if selection spans ListItemNodes under a FormulaDisplayNode, we don't allow deletion
function $shouldNotDelete(): boolean {
  const selection = $getSelection();
  if (selection === null || !$isRangeSelection(selection) || selection.isCollapsed()) return false;
  const selectionNodes = selection?.getNodes();
  const anchorLI = $getListItemContainingNode(selection.anchor.getNode());
  const focusLI = $getListItemContainingNode(selection.focus.getNode());
  if (anchorLI === focusLI) return false;
  const anchorAncestor = getAncestorFormulaDisplayNode(anchorLI);
  const focusAncestor = getAncestorFormulaDisplayNode(focusLI);
  if (
    (anchorAncestor && !selectionNodes.includes(anchorAncestor))
    || 
    (focusAncestor && !selectionNodes.includes(focusAncestor))
  ) return true;
  return false;
}

export function registerFormulaCommandHandlers(
  editor: LexicalEditor,
  updatingNodeKey: MutableRefObject<string | null>,
  setUpdatingNodeKey: (updatingNodeKey: string | null) => void,
  setLocalSharedNodeMap: React.Dispatch<React.SetStateAction<Map<string, NodeElementMarkdown>>>,
  setLocalChildNodeMap: React.Dispatch<React.SetStateAction<Map<string, ChildSharedNodeReference>>>
  ) {
    return mergeRegister(
      editor.registerNodeTransform(FormattableTextNode, (node) => {
        const parentNode = node.getParent();
        if (
          !(parentNode instanceof ListItemNode) ||
          node.getIndexWithinParent() !== 0 ||
          node instanceof FormulaEditorNode
        ) {
          return;
        }
        const textContents = parentNode.getTextContent();
        const { formula: formulaText, result: resultString } =
          parseFormulaMarkdown(textContents);
        if (formulaText && resultString) {
          const formulaDisplayNode = $createFormulaDisplayNode(
            formulaText,
            resultString
          );
          parentNode.splice(
            0,
            parentNode.getChildrenSize(),
            [formulaDisplayNode]
          );
          //node.replace(formulaDisplayNode);
        } else if (textContents.startsWith("=")) {
          $replaceTextNodeWithEditor(node);
        }
      }),
      editor.registerNodeTransform(FormulaEditorNode, (node) => {
        // this logic is mostly around making sure if we serialize a FormulaEditorNode
        // that it is turned back into a FormulaDisplayNode when the editor is reloaded
        // TODO maybe handle this in FormulaEditorNode.importJSON instead?
        
        const textContents = node.getTextContent();

        if (!textContents.startsWith("=")) {
          $replaceEditorWithTextNode(node);
        } else {
          const selection = $getSelection();
          if (
            selection === null ||
            !$isRangeSelection(selection) ||
            !selection.isCollapsed()
          ) {
            $replaceWithFormulaDisplayNode(node);
          }
          const selectionListItemNode =
            $getActiveListItemFromSelection(selection);
          if (selectionListItemNode) {
            const editorListItemNode = node.getParent();
            if (
              editorListItemNode && 
              selectionListItemNode.getKey() !== editorListItemNode.getKey()
            ) {
              $replaceWithFormulaDisplayNode(node);
            }
          }
        }
      }),
      editor.registerCommand(
        SELECTION_CHANGE_COMMAND,
        () => {
          if (!haveExistingFormulaEditorNode()) return false;

          const selection = $getSelection();
          if (selection === null) return false;

          if ($isNodeSelection(selection)) {
            const node = selection.getNodes()[0];
            if (node.getKey() !== getFormulaEditorNodeKey()) {
              $replaceExistingFormulaEditorNode();
            }
            return false;
          }

          if (!$isRangeSelection(selection) || !selection.isCollapsed()) {
            return false;
          }

          const activeNode = selection.anchor.getNode();
          const activeListItem = $getListItemContainingNode(activeNode);
          const activeListItemFirstChild = activeListItem?.getFirstChild();

          if (activeListItemFirstChild?.getKey() !== getFormulaEditorNodeKey()) {
            // we're about to get rid of the node that has (had) the selection
            // before the selection change handler has completed, so we have to
            // fix the selection here
            let anchorOffset = undefined;
            if ($isTextNode(activeNode)) {
              anchorOffset = selection.anchor.offset;
            }
            $replaceExistingFormulaEditorNode();
            if (anchorOffset) {
              activeNode.select(anchorOffset);
            } else {
              activeNode.selectEnd();
            }
          }

          return false;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        SWAP_FORMULA_DISPLAY_FOR_EDITOR,
        ({ displayNodeKey }) => {
          const displayNode = $getNodeByKey(displayNodeKey);
          if (displayNode && $isFormulaDisplayNode(displayNode)) {
            $replaceDisplayNodeWithEditor(displayNode);
          }
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        SWAP_FORMULA_EDITOR_FOR_DISPLAY,
        () => {
          const editorNode = $getNodeByKey(getFormulaEditorNodeKey());
          if (editorNode && $isFormulaEditorNode(editorNode)) {
            $replaceExistingFormulaEditorNode();
          }
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        STORE_FORMULA_OUTPUT,
        ({ displayNodeKey, output }) => {
          const displayNode = $getNodeByKey(displayNodeKey);
          if (displayNode && $isFormulaDisplayNode(displayNode)) {
            displayNode.setOutput(output);
          }
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        CREATE_FORMULA_NODES,
        ({ displayNodeKey, nodesMarkdown }) => {

          // don't recreate the nodes if the given display node is the source of the update
          if (displayNodeKey === updatingNodeKey.current) {
            setUpdatingNodeKey(null);
            return true;
          }
          const displayNode = $getNodeByKey(displayNodeKey);
          if (displayNode && $isFormulaDisplayNode(displayNode)) {
            createFormulaOutputNodes(
              editor,
              displayNode,
              nodesMarkdown,
              setLocalSharedNodeMap,
              setLocalChildNodeMap
            );
          }
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        ADD_FORMULA_NODES,
        ({ displayNodeKey, nodesMarkdown }) => {
          const displayNode = $getNodeByKey(displayNodeKey);
          if (displayNode && $isFormulaDisplayNode(displayNode)) {
            addFormulaOutputNodes(editor, displayNode, nodesMarkdown, setLocalSharedNodeMap, setLocalChildNodeMap);
          }
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        DELETE_CHARACTER_COMMAND,
        () => {
          return $shouldNotDelete();
        },
        COMMAND_PRIORITY_HIGH
      ),
      editor.registerCommand(
        REMOVE_TEXT_COMMAND,
        () => {
          return $shouldNotDelete();
        }, 
        COMMAND_PRIORITY_CRITICAL
      ),
      editor.registerCommand(
        CUT_COMMAND,
        () => {
          return $shouldNotDelete();
        }, 
        COMMAND_PRIORITY_CRITICAL
      ),
      editor.registerCommand(
        INDENT_LISTITEM_COMMAND,
        (payload) => {
          const { listItem } = payload;
          const formulaDisplayNode = getAncestorFormulaDisplayNode(listItem);
          if (formulaDisplayNode) {
            return true;
          }
          return false;
        },
        COMMAND_PRIORITY_HIGH
      ),
      editor.registerCommand(
        OUTDENT_LISTITEM_COMMAND,
        (payload) => {
          const { listItem } = payload;
          const formulaDisplayNode = getAncestorFormulaDisplayNode(listItem);
          if (formulaDisplayNode) {
            return true;
          }
          return false;
        },
        COMMAND_PRIORITY_HIGH
      ),
      editor.registerCommand(
        OUTDENT_CONTENT_COMMAND,
        (payload) => {
          const selection = $getSelection();
          if (selection === null || !$isRangeSelection(selection) || !selection.isCollapsed()) return false;
          const anchorLI = $getListItemContainingNode(selection.anchor.getNode());
          if (!anchorLI) return false;
          const anchorAncestor = getAncestorFormulaDisplayNode(anchorLI);
          if (anchorAncestor) return true;
          return false;
        },
        COMMAND_PRIORITY_HIGH
      ),
      editor.registerCommand(
        INSERT_PARAGRAPH_COMMAND,
        (payload) => {
          const selection = $getSelection();
          if (selection === null || !$isRangeSelection(selection) || !selection.isCollapsed()) return false;
          const anchorLI = $getListItemContainingNode(selection.anchor.getNode());
          if (!anchorLI) return false;
          const displayNode = getAncestorFormulaDisplayNode(anchorLI);
          if (displayNode) return true;
          return false;
        },
        COMMAND_PRIORITY_HIGH
      ),
      editor.registerCommand(
        COPY_COMMAND,
        (event: ClipboardEvent | null) => {
          const selection = $getSelection();
          if (selection === null) {
            const windowSelection = window.getSelection();
            if (windowSelection && windowSelection.rangeCount > 0) {
              const range = windowSelection.getRangeAt(0);
              let currentNode = range.commonAncestorContainer as Node;

              while (currentNode && currentNode !== document.body) {
                if (currentNode.nodeType === Node.ELEMENT_NODE) {
                  const element = currentNode as HTMLElement;
                  if (element.tagName.toLowerCase() === 'div') {
                    // TODO probably there's a better way to figure out if the selection is within a FormulaDisplayComponent
                    if (element.classList.contains('border-formulaBorderColor')) {
                      event?.clipboardData?.setData('text/plain', windowSelection.toString());
                      return true;
                    } else {
                      return false;
                    }
                  }
                }
                currentNode = currentNode.parentNode as Node;
              }
            }
            return false;
          }
          return false;
        },
        COMMAND_PRIORITY_CRITICAL
      ),
      editor.registerCommand(
        PASTE_COMMAND,
        (event: ClipboardEvent | null) => {
          if (!haveExistingFormulaEditorNode() || !event) return false;

          const selection = $getSelection();
          if (selection === null || !$isRangeSelection(selection)) return false;

          const activeNode = selection.anchor.getNode();
          if (activeNode.getKey() !== getFormulaEditorNodeKey()) return false;

          const text = event?.clipboardData?.getData('text/plain') || event?.clipboardData?.getData('text/uri-list');
          if (!text) return false;

          // replace newlines with spaces
          const textSansNewlines = text.replace(/\n/g, ' ');

          selection.insertText(textSansNewlines);

          return true;
        },
        COMMAND_PRIORITY_CRITICAL
      )
    );
  }